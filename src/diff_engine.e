note
	description: "Core Myers diff algorithm implementation for computing edit script"
	author: "Generated by simple_codegen"
	date: "$Date$"
	revision: "$Revision$"

class
	DIFF_ENGINE

create
	make

feature {NONE} -- Initialization

	make
			-- Create a new diff engine.
		do
			create source_lines.make (100)
			create target_lines.make (100)
			context_size := Default_context_size
		ensure
			source_empty: source_lines.is_empty
			target_empty: target_lines.is_empty
			default_context: context_size = Default_context_size
		end

feature -- Access

	source_lines: ARRAYED_LIST [STRING]
			-- Lines from source text

	target_lines: ARRAYED_LIST [STRING]
			-- Lines from target text

	context_size: INTEGER
			-- Number of context lines around changes

feature -- Settings

	set_source (a_lines: ARRAYED_LIST [STRING])
			-- Set source lines for comparison.
		do
			source_lines := a_lines
		ensure
			source_set: source_lines = a_lines
		end

	set_target (a_lines: ARRAYED_LIST [STRING])
			-- Set target lines for comparison.
		do
			target_lines := a_lines
		ensure
			target_set: target_lines = a_lines
		end

	set_source_from_string (a_text: STRING)
			-- Set source from text, splitting on newlines.
		do
			source_lines := split_lines (a_text)
		ensure
			source_set: source_lines /= Void
			empty_text_gives_empty: a_text.is_empty implies source_lines.count = 1
		end

	set_target_from_string (a_text: STRING)
			-- Set target from text, splitting on newlines.
		do
			target_lines := split_lines (a_text)
		ensure
			target_set: target_lines /= Void
			empty_text_gives_empty: a_text.is_empty implies target_lines.count = 1
		end

	set_context_size (a_size: INTEGER)
			-- Set number of context lines.
		require
			non_negative: a_size >= 0
		do
			context_size := a_size
		ensure
			context_set: context_size = a_size
		end

feature -- Computation

	compute_diff: DIFF_RESULT
			-- Compute diff between source and target.
			-- Uses Myers algorithm via LCS to produce minimal edit script.
		local
			l_lcs: ARRAYED_LIST [TUPLE [source_idx: INTEGER; target_idx: INTEGER]]
			l_result: DIFF_RESULT
			l_changes: ARRAYED_LIST [TUPLE [op: INTEGER; source_idx: INTEGER; target_idx: INTEGER]]
		do
			create l_result.make
			l_lcs := compute_lcs
			l_changes := compute_edit_script (l_lcs)
			build_hunks (l_result, l_changes)
			Result := l_result
		ensure
			result_exists: Result /= Void
			identical_if_same: source_lines.count = target_lines.count and then
				(across 1 |..| source_lines.count as ic all
					source_lines [ic.item].same_string (target_lines [ic.item])
				end) implies Result.is_identical
			hunks_ordered: across 1 |..| (Result.hunks.count - 1) as ic all
				Result.hunks [ic.item].source_start <= Result.hunks [ic.item + 1].source_start
			end
		end

feature {NONE} -- Implementation

	compute_lcs: ARRAYED_LIST [TUPLE [source_idx: INTEGER; target_idx: INTEGER]]
			-- Compute longest common subsequence using dynamic programming.
			-- Uses 1-offset indexing: dp[i+1, j+1] holds LCS length for source[1..i], target[1..j]
		local
			l_m, l_n, l_i, l_j: INTEGER
			l_dp: ARRAY2 [INTEGER]
			l_result: ARRAYED_LIST [TUPLE [source_idx: INTEGER; target_idx: INTEGER]]
		do
			l_m := source_lines.count
			l_n := target_lines.count
			-- Create (m+1) x (n+1) table with 1-based indices
			-- Row 1, Col 1 are base cases (zero LCS with empty string)
			create l_dp.make_filled (0, l_m + 1, l_n + 1)

			-- Build DP table
			-- Source lines are at indices 1..l_m, stored at dp rows 2..l_m+1
			-- Target lines are at indices 1..l_n, stored at dp cols 2..l_n+1
			from l_i := 1 until l_i > l_m loop
				from l_j := 1 until l_j > l_n loop
					if source_lines [l_i].same_string (target_lines [l_j]) then
						l_dp [l_i + 1, l_j + 1] := l_dp [l_i, l_j] + 1
					else
						l_dp [l_i + 1, l_j + 1] := l_dp [l_i, l_j + 1].max (l_dp [l_i + 1, l_j])
					end
					l_j := l_j + 1
				end
				l_i := l_i + 1
			end

			-- Backtrack to find LCS starting from dp[l_m + 1, l_n + 1]
			create l_result.make (l_dp [l_m + 1, l_n + 1])
			l_i := l_m
			l_j := l_n
			from until l_i = 0 or l_j = 0 loop
				if source_lines [l_i].same_string (target_lines [l_j]) then
					l_result.put_front ([l_i, l_j])
					l_i := l_i - 1
					l_j := l_j - 1
				elseif l_dp [l_i, l_j + 1] > l_dp [l_i + 1, l_j] then
					l_i := l_i - 1
				else
					l_j := l_j - 1
				end
			end

			Result := l_result
		ensure
			result_not_void: Result /= Void
		end

	compute_edit_script (a_lcs: ARRAYED_LIST [TUPLE [source_idx: INTEGER; target_idx: INTEGER]]): ARRAYED_LIST [TUPLE [op: INTEGER; source_idx: INTEGER; target_idx: INTEGER]]
			-- Convert LCS to edit script (list of operations).
			-- op: 0=match, 1=insert, 2=delete
		local
			l_result: ARRAYED_LIST [TUPLE [op: INTEGER; source_idx: INTEGER; target_idx: INTEGER]]
			l_si, l_ti, l_lcs_idx: INTEGER
			l_lcs_source, l_lcs_target: INTEGER
		do
			create l_result.make (source_lines.count + target_lines.count)
			l_si := 1
			l_ti := 1
			l_lcs_idx := 1

			from until l_si > source_lines.count and l_ti > target_lines.count loop
				if l_lcs_idx <= a_lcs.count then
					l_lcs_source := a_lcs [l_lcs_idx].source_idx
					l_lcs_target := a_lcs [l_lcs_idx].target_idx
				else
					l_lcs_source := source_lines.count + 1
					l_lcs_target := target_lines.count + 1
				end

				if l_si <= source_lines.count and l_si < l_lcs_source then
					-- Delete from source
					l_result.extend ([Op_delete, l_si, 0])
					l_si := l_si + 1
				elseif l_ti <= target_lines.count and l_ti < l_lcs_target then
					-- Insert from target
					l_result.extend ([Op_insert, 0, l_ti])
					l_ti := l_ti + 1
				elseif l_si <= source_lines.count and l_ti <= target_lines.count then
					-- Match
					l_result.extend ([Op_match, l_si, l_ti])
					l_si := l_si + 1
					l_ti := l_ti + 1
					l_lcs_idx := l_lcs_idx + 1
				elseif l_si <= source_lines.count then
					l_result.extend ([Op_delete, l_si, 0])
					l_si := l_si + 1
				elseif l_ti <= target_lines.count then
					l_result.extend ([Op_insert, 0, l_ti])
					l_ti := l_ti + 1
				end
			end

			Result := l_result
		ensure
			result_not_void: Result /= Void
		end

	build_hunks (a_result: DIFF_RESULT; a_changes: ARRAYED_LIST [TUPLE [op: INTEGER; source_idx: INTEGER; target_idx: INTEGER]])
			-- Build hunks from edit script with context.
		local
			l_hunk: detachable DIFF_HUNK
			l_i, l_start, l_end: INTEGER
			l_change: TUPLE [op: INTEGER; source_idx: INTEGER; target_idx: INTEGER]
			l_source_start, l_target_start: INTEGER
		do
			if a_changes.is_empty then
				-- No changes, result stays empty
			else
				-- Find regions with changes and build hunks
				from
					l_i := 1
				until
					l_i > a_changes.count
				loop
					l_change := a_changes [l_i]
					if l_change.op /= Op_match then
						-- Found a change, collect context and build hunk
						l_start := (l_i - context_size).max (1)
						l_end := find_hunk_end (a_changes, l_i)

						-- Determine starting line numbers
						l_source_start := find_source_start (a_changes, l_start)
						l_target_start := find_target_start (a_changes, l_start)

						create l_hunk.make (l_source_start.max (1), l_target_start.max (1))
						add_hunk_lines (l_hunk, a_changes, l_start, l_end)
						a_result.add_hunk (l_hunk)

						l_i := l_end + 1
					else
						l_i := l_i + 1
					end
				end
			end
		end

	find_hunk_end (a_changes: ARRAYED_LIST [TUPLE [op: INTEGER; source_idx: INTEGER; target_idx: INTEGER]]; a_start: INTEGER): INTEGER
			-- Find end of hunk including trailing context.
		local
			l_i, l_last_change: INTEGER
		do
			l_last_change := a_start
			from l_i := a_start until l_i > a_changes.count loop
				if a_changes [l_i].op /= Op_match then
					l_last_change := l_i
				elseif l_i - l_last_change > context_size * 2 then
					-- Gap too large, end hunk
					Result := (l_last_change + context_size).min (a_changes.count)
					l_i := a_changes.count + 1 -- exit loop
				end
				l_i := l_i + 1
			end
			if Result = 0 then
				Result := (l_last_change + context_size).min (a_changes.count)
			end
		ensure
			valid_end: Result >= a_start and Result <= a_changes.count
		end

	find_source_start (a_changes: ARRAYED_LIST [TUPLE [op: INTEGER; source_idx: INTEGER; target_idx: INTEGER]]; a_idx: INTEGER): INTEGER
			-- Find source line number at given index.
		local
			l_i: INTEGER
		do
			Result := 1
			from l_i := 1 until l_i >= a_idx loop
				if a_changes [l_i].op /= Op_insert then
					Result := Result + 1
				end
				l_i := l_i + 1
			end
		end

	find_target_start (a_changes: ARRAYED_LIST [TUPLE [op: INTEGER; source_idx: INTEGER; target_idx: INTEGER]]; a_idx: INTEGER): INTEGER
			-- Find target line number at given index.
		local
			l_i: INTEGER
		do
			Result := 1
			from l_i := 1 until l_i >= a_idx loop
				if a_changes [l_i].op /= Op_delete then
					Result := Result + 1
				end
				l_i := l_i + 1
			end
		end

	add_hunk_lines (a_hunk: DIFF_HUNK; a_changes: ARRAYED_LIST [TUPLE [op: INTEGER; source_idx: INTEGER; target_idx: INTEGER]]; a_start, a_end: INTEGER)
			-- Add lines to hunk from change range.
		local
			l_i: INTEGER
			l_change: TUPLE [op: INTEGER; source_idx: INTEGER; target_idx: INTEGER]
			l_source_line, l_target_line: INTEGER
		do
			l_source_line := find_source_start (a_changes, a_start)
			l_target_line := find_target_start (a_changes, a_start)

			from l_i := a_start until l_i > a_end loop
				l_change := a_changes [l_i]
				inspect l_change.op
				when Op_match then
					if l_change.source_idx >= 1 and l_change.source_idx <= source_lines.count then
						a_hunk.add_context_line (source_lines [l_change.source_idx], l_source_line, l_target_line)
					end
					l_source_line := l_source_line + 1
					l_target_line := l_target_line + 1
				when Op_insert then
					if l_change.target_idx >= 1 and l_change.target_idx <= target_lines.count then
						a_hunk.add_added_line (target_lines [l_change.target_idx], l_target_line)
					end
					l_target_line := l_target_line + 1
				when Op_delete then
					if l_change.source_idx >= 1 and l_change.source_idx <= source_lines.count then
						a_hunk.add_removed_line (source_lines [l_change.source_idx], l_source_line)
					end
					l_source_line := l_source_line + 1
				else
					-- Unknown operation, skip
				end
				l_i := l_i + 1
			end
		end

	split_lines (a_text: STRING): ARRAYED_LIST [STRING]
			-- Split text into lines.
		local
			l_lines: LIST [STRING]
			l_line: STRING
			i: INTEGER
		do
			l_lines := a_text.split ('%N')
			create Result.make (l_lines.count)
			from
				i := 1
			until
				i > l_lines.count
			loop
				l_line := l_lines [i]
				-- Remove trailing CR if present (Windows line endings)
				if l_line.count > 0 and then l_line.item (l_line.count) = '%R' then
					Result.extend (l_line.substring (1, l_line.count - 1))
				else
					Result.extend (l_line)
				end
				i := i + 1
			end
		ensure
			result_not_void: Result /= Void
		end

feature {NONE} -- Constants

	Default_context_size: INTEGER = 3
			-- Default number of context lines around changes

	Op_match: INTEGER = 0
	Op_insert: INTEGER = 1
	Op_delete: INTEGER = 2

invariant
	source_not_void: source_lines /= Void
	target_not_void: target_lines /= Void
	context_non_negative: context_size >= 0

end

note
	description: "Facade class providing quick diff methods for comparing files, strings, and directories"
	author: "Generated by simple_codegen"
	date: "$Date$"
	revision: "$Revision$"

class
	SIMPLE_DIFF

create
	make

feature {NONE} -- Initialization

	make
			-- Create diff facade with default settings.
		do
			context_lines := 3
			ignore_whitespace := False
			ignore_case := False
			create engine.make
		ensure
			default_context: context_lines = 3
			no_whitespace_ignore: not ignore_whitespace
			no_case_ignore: not ignore_case
		end

feature -- Access

	context_lines: INTEGER
			-- Number of context lines in unified diff (default 3)

	ignore_whitespace: BOOLEAN
			-- Whether to ignore whitespace differences

	ignore_case: BOOLEAN
			-- Whether to ignore case differences

	Version: STRING = "1.0.0"
			-- Library version

feature -- Settings (Builder pattern)

	set_context_lines (a_count: INTEGER): like Current
			-- Set number of context lines (builder pattern).
		require
			non_negative: a_count >= 0
		do
			context_lines := a_count
			engine.set_context_size (a_count)
			Result := Current
		ensure
			context_set: context_lines = a_count
			returns_self: Result = Current
		end

	set_ignore_whitespace (a_value: BOOLEAN): like Current
			-- Set whitespace ignoring (builder pattern).
		do
			ignore_whitespace := a_value
			Result := Current
		ensure
			whitespace_set: ignore_whitespace = a_value
			returns_self: Result = Current
		end

	set_ignore_case (a_value: BOOLEAN): like Current
			-- Set case ignoring (builder pattern).
		do
			ignore_case := a_value
			Result := Current
		ensure
			case_set: ignore_case = a_value
			returns_self: Result = Current
		end

feature -- String diffing

	diff_strings (a_source, a_target: STRING): DIFF_RESULT
			-- Compare two strings, return DIFF_RESULT.
		require
			source_not_void: a_source /= Void
			target_not_void: a_target /= Void
		local
			l_source, l_target: STRING
		do
			l_source := preprocess_string (a_source)
			l_target := preprocess_string (a_target)
			engine.set_source_from_string (l_source)
			engine.set_target_from_string (l_target)
			Result := engine.compute_diff
		ensure
			result_not_void: Result /= Void
		end

feature -- File diffing

	diff_files (a_source_path, a_target_path: STRING): DIFF_RESULT
			-- Compare two files, return DIFF_RESULT.
		require
			source_not_void: a_source_path /= Void
			target_not_void: a_target_path /= Void
		local
			l_source_content, l_target_content: STRING
		do
			l_source_content := read_file (a_source_path)
			l_target_content := read_file (a_target_path)
			Result := diff_strings (l_source_content, l_target_content)
			Result.set_source_path (a_source_path)
			Result.set_target_path (a_target_path)
		ensure
			result_not_void: Result /= Void
			source_path_set: Result.source_path /= Void
			target_path_set: Result.target_path /= Void
		end

	diff_file_to_string (a_file_path: STRING; a_content: STRING): DIFF_RESULT
			-- Compare file to string content.
		require
			path_not_void: a_file_path /= Void
			content_not_void: a_content /= Void
		local
			l_file_content: STRING
		do
			l_file_content := read_file (a_file_path)
			Result := diff_strings (l_file_content, a_content)
			Result.set_source_path (a_file_path)
		ensure
			result_not_void: Result /= Void
		end

feature -- Directory diffing

	diff_directories (a_source_dir, a_target_dir: STRING): ARRAYED_LIST [DIFF_RESULT]
			-- Compare two directories recursively, return list of DIFF_RESULT.
		require
			source_not_void: a_source_dir /= Void
			target_not_void: a_target_dir /= Void
		local
			l_source_files, l_target_files: ARRAYED_LIST [STRING]
			l_all_files: HASH_TABLE [INTEGER, STRING]
			l_source_path, l_target_path, l_filename: STRING
			l_diff: DIFF_RESULT
			l_value: INTEGER
			l_sep: STRING
			i: INTEGER
		do
			create Result.make (20)
			l_source_files := list_files_recursive (a_source_dir)
			l_target_files := list_files_recursive (a_target_dir)
			l_sep := operating_environment.directory_separator.out

			-- Build set of all files
			create l_all_files.make (l_source_files.count + l_target_files.count)
			from i := 1 until i > l_source_files.count loop
				l_all_files.put (1, l_source_files [i])  -- 1 = in source
				i := i + 1
			end
			from i := 1 until i > l_target_files.count loop
				l_filename := l_target_files [i]
				if l_all_files.has (l_filename) then
					l_all_files.replace (3, l_filename)  -- 3 = in both
				else
					l_all_files.put (2, l_filename)  -- 2 = in target only
				end
				i := i + 1
			end

			-- Compare files
			from l_all_files.start until l_all_files.after loop
				l_filename := l_all_files.key_for_iteration
				l_value := l_all_files.item_for_iteration
				l_source_path := a_source_dir + l_sep + l_filename
				l_target_path := a_target_dir + l_sep + l_filename
				inspect l_value
				when 1 then
					-- File only in source (deleted)
					l_diff := diff_strings (read_file (l_source_path), "")
					l_diff.set_source_path (l_source_path)
					l_diff.set_target_path (l_target_path)
					Result.extend (l_diff)
				when 2 then
					-- File only in target (added)
					l_diff := diff_strings ("", read_file (l_target_path))
					l_diff.set_source_path (l_source_path)
					l_diff.set_target_path (l_target_path)
					Result.extend (l_diff)
				when 3 then
					-- File in both
					l_diff := diff_files (l_source_path, l_target_path)
					if l_diff.has_changes then
						Result.extend (l_diff)
					end
				else
					-- Unknown state, skip
				end
				l_all_files.forth
			end
		ensure
			result_not_void: Result /= Void
		end

feature -- Patch operations

	apply_patch (a_diff: DIFF_RESULT; a_file_path: STRING)
			-- Apply a unified diff to a file.
			-- Sets `has_error` and `last_error` if application fails.
		require
			diff_not_void: a_diff /= Void
			path_not_void: a_file_path /= Void
		local
			l_applier: PATCH_APPLIER
		do
			create l_applier.make
			l_applier.apply (a_diff, a_file_path)
			if l_applier.has_error then
				last_error := l_applier.last_error
			end
		ensure
			error_propagated: has_error implies last_error /= Void
		end

	apply_patch_dry_run (a_diff: DIFF_RESULT; a_file_path: STRING): STRING
			-- Apply diff in dry-run mode, return result without modifying file.
		require
			diff_not_void: a_diff /= Void
			path_not_void: a_file_path /= Void
		local
			l_applier: PATCH_APPLIER
			l_content: STRING
		do
			create l_applier.make
			l_applier.set_dry_run (True)
			l_content := read_file (a_file_path)
			Result := l_applier.apply_to_string (a_diff, l_content)
		ensure
			result_not_void: Result /= Void
		end

	reverse_patch (a_diff: DIFF_RESULT; a_file_path: STRING)
			-- Reverse apply a patch (unapply).
			-- Sets `has_error` and `last_error` if reversal fails.
		require
			diff_not_void: a_diff /= Void
			path_not_void: a_file_path /= Void
		local
			l_applier: PATCH_APPLIER
		do
			create l_applier.make
			l_applier.set_reverse (True)
			l_applier.apply (a_diff, a_file_path)
			if l_applier.has_error then
				last_error := l_applier.last_error
			end
		ensure
			error_propagated: has_error implies last_error /= Void
		end

feature -- Error handling

	last_error: detachable STRING
			-- Last error message, if any

	has_error: BOOLEAN
			-- True if last operation had an error
		do
			Result := last_error /= Void
		end

	clear_error
			-- Clear any error state.
		do
			last_error := Void
		ensure
			no_error: not has_error
		end

feature {NONE} -- Implementation

	engine: DIFF_ENGINE
			-- The diff computation engine

	preprocess_string (a_str: STRING): STRING
			-- Preprocess string based on settings.
		do
			Result := a_str.twin
			if ignore_case then
				Result.to_lower
			end
			if ignore_whitespace then
				Result := normalize_whitespace (Result)
			end
		end

	normalize_whitespace (a_str: STRING): STRING
			-- Normalize whitespace (collapse multiple spaces, trim).
		local
			l_in_space: BOOLEAN
			i: INTEGER
			c: CHARACTER
		do
			create Result.make (a_str.count)
			from i := 1 until i > a_str.count loop
				c := a_str.item (i)
				if c = ' ' or c = '%T' then
					if not l_in_space and Result.count > 0 then
						Result.append_character (' ')
						l_in_space := True
					end
				else
					Result.append_character (c)
					l_in_space := False
				end
				i := i + 1
			end
			Result.right_adjust
			Result.left_adjust
		end

	read_file (a_path: STRING): STRING
			-- Read entire file content.
		local
			l_file: PLAIN_TEXT_FILE
		do
			create l_file.make_with_name (a_path)
			if l_file.exists and l_file.is_readable then
				l_file.open_read
				l_file.read_stream (l_file.count)
				Result := l_file.last_string
				l_file.close
			else
				create Result.make_empty
				last_error := "Cannot read file: " + a_path
			end
		ensure
			result_not_void: Result /= Void
		end

	list_files_recursive (a_dir: STRING): ARRAYED_LIST [STRING]
			-- List all files in directory recursively (relative paths).
		local
			l_dir: DIRECTORY
			l_entries: ARRAYED_LIST [STRING]
			l_path, l_entry, l_sep: STRING
			l_file: PLAIN_TEXT_FILE
			l_sub_dir: DIRECTORY
			l_sub_files: ARRAYED_LIST [STRING]
			i, j: INTEGER
		do
			create Result.make (50)
			create l_dir.make (a_dir)
			l_sep := operating_environment.directory_separator.out
			if l_dir.exists then
				l_dir.open_read
				l_entries := l_dir.linear_representation
				l_dir.close

				from i := 1 until i > l_entries.count loop
					l_entry := l_entries [i]
					if not l_entry.same_string (".") and not l_entry.same_string ("..") then
						l_path := a_dir + l_sep + l_entry
						create l_file.make_with_name (l_path)
						if l_file.exists and l_file.is_plain then
							Result.extend (l_entry)
						else
							create l_sub_dir.make (l_path)
							if l_sub_dir.exists then
								l_sub_files := list_files_recursive (l_path)
								from j := 1 until j > l_sub_files.count loop
									Result.extend (l_entry + l_sep + l_sub_files [j])
									j := j + 1
								end
							end
						end
					end
					i := i + 1
				end
			end
		ensure
			result_not_void: Result /= Void
		end

invariant
	context_lines_non_negative: context_lines >= 0
	engine_not_void: engine /= Void

end

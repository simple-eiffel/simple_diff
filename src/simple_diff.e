note
	description: "Facade class providing quick diff methods for comparing files, strings, and directories"
	author: "Generated by simple_codegen"
	date: "$Date$"
	revision: "$Revision$"

class
	SIMPLE_DIFF

create
	make

feature {NONE} -- Initialization

	make
			-- Create diff facade with default settings.
		do
			context_lines := Default_context_lines
			ignore_whitespace := False
			ignore_case := False
			create engine.make
		ensure
			default_context: context_lines = Default_context_lines
			no_whitespace_ignore: not ignore_whitespace
			no_case_ignore: not ignore_case
		end

feature -- Access

	context_lines: INTEGER
			-- Number of context lines in unified diff (default 3)

	ignore_whitespace: BOOLEAN
			-- Whether to ignore whitespace differences

	ignore_case: BOOLEAN
			-- Whether to ignore case differences

	Version: STRING = "1.0.0"
			-- Library version

feature -- Settings (Builder pattern)

	set_context_lines (a_count: INTEGER): like Current
			-- Set number of context lines (builder pattern).
		require
			non_negative: a_count >= 0
		do
			context_lines := a_count
			engine.set_context_size (a_count)
			Result := Current
		ensure
			context_set: context_lines = a_count
			returns_self: Result = Current
		end

	set_ignore_whitespace (a_value: BOOLEAN): like Current
			-- Set whitespace ignoring (builder pattern).
		do
			ignore_whitespace := a_value
			Result := Current
		ensure
			whitespace_set: ignore_whitespace = a_value
			returns_self: Result = Current
		end

	set_ignore_case (a_value: BOOLEAN): like Current
			-- Set case ignoring (builder pattern).
		do
			ignore_case := a_value
			Result := Current
		ensure
			case_set: ignore_case = a_value
			returns_self: Result = Current
		end

feature -- String diffing

	diff_strings (a_source, a_target: STRING): DIFF_RESULT
			-- Compare two strings, return DIFF_RESULT.
		local
			l_source, l_target: STRING
		do
			l_source := preprocess_string (a_source)
			l_target := preprocess_string (a_target)
			engine.set_source_from_string (l_source)
			engine.set_target_from_string (l_target)
			Result := engine.compute_diff
		ensure
			result_exists: Result /= Void
			identical_when_same: a_source.same_string (a_target) implies Result.is_identical
		end

feature -- File diffing

	diff_files (a_source_path, a_target_path: STRING): DIFF_RESULT
			-- Compare two files, return DIFF_RESULT.
		require
			source_not_empty: not a_source_path.is_empty
			target_not_empty: not a_target_path.is_empty
		local
			l_source_content, l_target_content: STRING
		do
			l_source_content := read_file (a_source_path)
			l_target_content := read_file (a_target_path)
			Result := diff_strings (l_source_content, l_target_content)
			Result.set_source_path (a_source_path)
			Result.set_target_path (a_target_path)
		ensure
			result_exists: Result /= Void
			source_path_set: attached Result.source_path
			target_path_set: attached Result.target_path
			paths_match: attached Result.source_path as sp implies sp.same_string (a_source_path)
		end

	diff_file_to_string (a_file_path: STRING; a_content: STRING): DIFF_RESULT
			-- Compare file to string content.
		require
			path_not_empty: not a_file_path.is_empty
		local
			l_file_content: STRING
		do
			l_file_content := read_file (a_file_path)
			Result := diff_strings (l_file_content, a_content)
			Result.set_source_path (a_file_path)
		ensure
			result_exists: Result /= Void
			source_path_set: attached Result.source_path
		end

feature -- Directory diffing

	diff_directories (a_source_dir, a_target_dir: STRING): ARRAYED_LIST [DIFF_RESULT]
			-- Compare two directories recursively, return list of DIFF_RESULT.
		require
			source_not_empty: not a_source_dir.is_empty
			target_not_empty: not a_target_dir.is_empty
		local
			l_source_files, l_target_files: ARRAYED_LIST [STRING]
			l_all_files: HASH_TABLE [INTEGER, STRING]
			l_source_path, l_target_path, l_filename: STRING
			l_diff: DIFF_RESULT
			l_value: INTEGER
			l_sep: STRING
			i: INTEGER
		do
			create Result.make (20)
			l_source_files := list_files_recursive (a_source_dir)
			l_target_files := list_files_recursive (a_target_dir)
			l_sep := operating_environment.directory_separator.out

			-- Build set of all files
			create l_all_files.make (l_source_files.count + l_target_files.count)
			from i := 1 until i > l_source_files.count loop
				l_all_files.put (File_in_source_only, l_source_files [i])
				i := i + 1
			end
			from i := 1 until i > l_target_files.count loop
				l_filename := l_target_files [i]
				if l_all_files.has (l_filename) then
					l_all_files.replace (File_in_both, l_filename)
				else
					l_all_files.put (File_in_target_only, l_filename)
				end
				i := i + 1
			end

			-- Compare files
			from l_all_files.start until l_all_files.after loop
				l_filename := l_all_files.key_for_iteration
				l_value := l_all_files.item_for_iteration
				l_source_path := a_source_dir + l_sep + l_filename
				l_target_path := a_target_dir + l_sep + l_filename
				inspect l_value
				when File_in_source_only then
					-- File only in source (deleted)
					l_diff := diff_strings (read_file (l_source_path), "")
					l_diff.set_source_path (l_source_path)
					l_diff.set_target_path (l_target_path)
					Result.extend (l_diff)
				when File_in_target_only then
					-- File only in target (added)
					l_diff := diff_strings ("", read_file (l_target_path))
					l_diff.set_source_path (l_source_path)
					l_diff.set_target_path (l_target_path)
					Result.extend (l_diff)
				when File_in_both then
					-- File in both directories
					l_diff := diff_files (l_source_path, l_target_path)
					if l_diff.has_changes then
						Result.extend (l_diff)
					end
				else
					-- Unknown state, skip
				end
				l_all_files.forth
			end
		ensure
			result_not_void: Result /= Void
		end

feature -- Object Comparison (simple_reflection integration)

	diff_objects (a_source, a_target: ANY): ARRAYED_LIST [TUPLE [field_name: STRING; source_value: STRING; target_value: STRING]]
			-- Compare two objects field-by-field using reflection.
			-- Returns list of differing fields with their values.
		local
			l_source_reflected, l_target_reflected: SIMPLE_REFLECTED_OBJECT
			l_source_field, l_target_field: SIMPLE_FIELD_INFO
			l_source_value, l_target_value: STRING
			l_field_name: STRING
			i: INTEGER
		do
			create Result.make (10)
			create l_source_reflected.make (a_source)
			create l_target_reflected.make (a_target)

			from
				i := 1
			until
				i > l_source_reflected.type_info.fields.count
			loop
				l_source_field := l_source_reflected.type_info.fields [i]
				l_field_name := l_source_field.name.to_string_8

				-- Get source value
				l_source_value := field_value_to_string (l_source_field.value (a_source))

				-- Try to find matching field in target
				l_target_value := ""
				if i <= l_target_reflected.type_info.fields.count then
					l_target_field := l_target_reflected.type_info.fields [i]
					if l_target_field.name.to_string_8.same_string (l_field_name) then
						l_target_value := field_value_to_string (l_target_field.value (a_target))
					end
				end

				-- Record difference if values differ
				if not l_source_value.same_string (l_target_value) then
					Result.extend ([l_field_name, l_source_value, l_target_value])
				end
				i := i + 1
			end
		ensure
			result_exists: Result /= Void
		end

	objects_equal (a_source, a_target: ANY): BOOLEAN
			-- Are two objects equal (all fields match)?
		do
			Result := diff_objects (a_source, a_target).is_empty
		ensure
			definition: Result = diff_objects (a_source, a_target).is_empty
		end

	diff_objects_as_string (a_source, a_target: ANY): STRING
			-- Return human-readable diff of two objects.
		local
			l_diffs: ARRAYED_LIST [TUPLE [field_name: STRING; source_value: STRING; target_value: STRING]]
		do
			l_diffs := diff_objects (a_source, a_target)
			create Result.make (100)
			if l_diffs.is_empty then
				Result.append ("Objects are equal")
			else
				Result.append ("Field differences:%N")
				across l_diffs as ic loop
					Result.append ("  ")
					Result.append (ic.field_name)
					Result.append (": '")
					Result.append (ic.source_value)
					Result.append ("' -> '")
					Result.append (ic.target_value)
					Result.append ("'%N")
				end
			end
		ensure
			result_exists: Result /= Void
		end

feature {NONE} -- Object Comparison Implementation

	field_value_to_string (a_value: detachable ANY): STRING
			-- Convert field value to string for comparison.
		do
			if a_value = Void then
				Result := "<void>"
			elseif attached {BOOLEAN} a_value as l_bool then
				Result := if l_bool then "true" else "false" end
			elseif attached {READABLE_STRING_GENERAL} a_value as l_str then
				Result := l_str.to_string_8
			else
				Result := a_value.out
			end
		ensure
			result_exists: Result /= Void
		end

feature -- Patch operations

	apply_patch (a_diff: DIFF_RESULT; a_file_path: STRING)
			-- Apply a unified diff to a file.
			-- Sets `has_error` and `last_error` if application fails.
		require
			path_not_empty: not a_file_path.is_empty
		local
			l_applier: PATCH_APPLIER
		do
			create l_applier.make
			l_applier.apply (a_diff, a_file_path)
			if l_applier.has_error then
				last_error := l_applier.last_error
			end
		ensure
			error_propagated: has_error implies last_error /= Void
		end

	apply_patch_dry_run (a_diff: DIFF_RESULT; a_file_path: STRING): STRING
			-- Apply diff in dry-run mode, return result without modifying file.
		require
			path_not_empty: not a_file_path.is_empty
		local
			l_applier: PATCH_APPLIER
			l_content: STRING
		do
			create l_applier.make
			l_applier.set_dry_run (True)
			l_content := read_file (a_file_path)
			Result := l_applier.apply_to_string (a_diff, l_content)
		ensure
			result_not_void: Result /= Void
		end

	reverse_patch (a_diff: DIFF_RESULT; a_file_path: STRING)
			-- Reverse apply a patch (unapply).
			-- Sets `has_error` and `last_error` if reversal fails.
		require
			path_not_empty: not a_file_path.is_empty
		local
			l_applier: PATCH_APPLIER
		do
			create l_applier.make
			l_applier.set_reverse (True)
			l_applier.apply (a_diff, a_file_path)
			if l_applier.has_error then
				last_error := l_applier.last_error
			end
		ensure
			error_propagated: has_error implies last_error /= Void
		end

feature -- Error handling

	last_error: detachable STRING
			-- Last error message, if any

	has_error: BOOLEAN
			-- True if last operation had an error
		do
			Result := last_error /= Void
		end

	clear_error
			-- Clear any error state.
		do
			last_error := Void
		ensure
			no_error: not has_error
		end

feature {NONE} -- Implementation

	engine: DIFF_ENGINE
			-- The diff computation engine

	preprocess_string (a_str: STRING): STRING
			-- Preprocess string based on settings.
		do
			Result := a_str.twin
			if ignore_case then
				Result.to_lower
			end
			if ignore_whitespace then
				Result := normalize_whitespace (Result)
			end
		end

	normalize_whitespace (a_str: STRING): STRING
			-- Normalize whitespace (collapse multiple spaces, trim).
		local
			l_in_space: BOOLEAN
			i: INTEGER
			c: CHARACTER
		do
			create Result.make (a_str.count)
			from i := 1 until i > a_str.count loop
				c := a_str.item (i)
				if c = ' ' or c = '%T' then
					if not l_in_space and Result.count > 0 then
						Result.append_character (' ')
						l_in_space := True
					end
				else
					Result.append_character (c)
					l_in_space := False
				end
				i := i + 1
			end
			Result.right_adjust
			Result.left_adjust
		end

	read_file (a_path: STRING): STRING
			-- Read entire file content.
		local
			l_file: PLAIN_TEXT_FILE
		do
			create l_file.make_with_name (a_path)
			if l_file.exists and l_file.is_readable then
				l_file.open_read
				l_file.read_stream (l_file.count)
				Result := l_file.last_string
				l_file.close
			else
				create Result.make_empty
				last_error := "Cannot read file: " + a_path
			end
		ensure
			result_not_void: Result /= Void
		end

	list_files_recursive (a_dir: STRING): ARRAYED_LIST [STRING]
			-- List all files in directory recursively (relative paths).
		local
			l_dir: DIRECTORY
			l_entries: ARRAYED_LIST [STRING]
			l_path, l_entry, l_sep: STRING
			l_file: PLAIN_TEXT_FILE
			l_sub_dir: DIRECTORY
			l_sub_files: ARRAYED_LIST [STRING]
			i, j: INTEGER
		do
			create Result.make (50)
			create l_dir.make (a_dir)
			l_sep := operating_environment.directory_separator.out
			if l_dir.exists then
				l_dir.open_read
				l_entries := l_dir.linear_representation
				l_dir.close

				from i := 1 until i > l_entries.count loop
					l_entry := l_entries [i]
					if not l_entry.same_string (".") and not l_entry.same_string ("..") then
						l_path := a_dir + l_sep + l_entry
						create l_file.make_with_name (l_path)
						if l_file.exists and l_file.is_plain then
							Result.extend (l_entry)
						else
							create l_sub_dir.make (l_path)
							if l_sub_dir.exists then
								l_sub_files := list_files_recursive (l_path)
								from j := 1 until j > l_sub_files.count loop
									Result.extend (l_entry + l_sep + l_sub_files [j])
									j := j + 1
								end
							end
						end
					end
					i := i + 1
				end
			end
		ensure
			result_not_void: Result /= Void
		end

feature {NONE} -- Constants

	Default_context_lines: INTEGER = 3
			-- Default number of context lines in unified diff

	File_in_source_only: INTEGER = 1
			-- File exists only in source directory

	File_in_target_only: INTEGER = 2
			-- File exists only in target directory

	File_in_both: INTEGER = 3
			-- File exists in both directories

invariant
	context_lines_non_negative: context_lines >= 0
	engine_not_void: engine /= Void

end

note
	description: "Applies unified diff patches to files with dry-run and reject file support"
	author: "Generated by simple_codegen"
	date: "$Date$"
	revision: "$Revision$"

class
	PATCH_APPLIER

create
	make

feature {NONE} -- Initialization

	make
			-- Create a patch applier with default settings.
		do
			dry_run := False
			reverse := False
			create rejected_hunks.make (5)
		ensure
			not_dry_run: not dry_run
			not_reverse: not reverse
			no_rejects: rejected_hunks.is_empty
			no_error: last_error = Void
		end

feature -- Access

	dry_run: BOOLEAN
			-- If true, do not actually modify files

	reverse: BOOLEAN
			-- If true, reverse the patch (unapply)

	last_error: detachable STRING
			-- Error message from last operation

	rejected_hunks: ARRAYED_LIST [DIFF_HUNK]
			-- Hunks that failed to apply

feature -- Status

	has_error: BOOLEAN
			-- True if last operation had errors
		do
			Result := last_error /= Void
		ensure
			definition: Result = (last_error /= Void)
		end

	has_rejects: BOOLEAN
			-- True if some hunks were rejected
		do
			Result := not rejected_hunks.is_empty
		ensure
			definition: Result = not rejected_hunks.is_empty
		end

feature -- Settings

	set_dry_run (a_value: BOOLEAN)
			-- Enable/disable dry run mode.
		do
			dry_run := a_value
		ensure
			dry_run_set: dry_run = a_value
		end

	set_reverse (a_value: BOOLEAN)
			-- Enable/disable reverse mode.
		do
			reverse := a_value
		ensure
			reverse_set: reverse = a_value
		end

feature -- Operations

	apply (a_diff: DIFF_RESULT; a_file_path: STRING)
			-- Apply diff result to file.
			-- Sets `has_error` if file not found or hunks failed.
			-- Sets `has_rejects` if some hunks could not be applied.
		require
			diff_not_void: a_diff /= Void
			path_not_void: a_file_path /= Void
		local
			l_file: PLAIN_TEXT_FILE
			l_lines: ARRAYED_LIST [STRING]
			l_result_lines: ARRAYED_LIST [STRING]
			l_content: STRING
		do
			clear_state

			-- Read file content
			create l_file.make_with_name (a_file_path)
			if not l_file.exists then
				last_error := "File not found: " + a_file_path
			else
				l_file.open_read
				l_file.read_stream (l_file.count)
				l_content := l_file.last_string
				l_file.close

				l_lines := split_lines (l_content)
				l_result_lines := apply_hunks (l_lines, a_diff.hunks)

				if not dry_run and last_error = Void then
					write_file (a_file_path, l_result_lines)
				end
			end
		ensure
			error_or_success: has_error or not has_error
			rejects_tracked: has_rejects implies rejected_hunks.count > 0
		end

	apply_to_string (a_diff: DIFF_RESULT; a_content: STRING): STRING
			-- Apply diff to string content, return result.
		require
			diff_not_void: a_diff /= Void
			content_not_void: a_content /= Void
		local
			l_lines: ARRAYED_LIST [STRING]
			l_result_lines: ARRAYED_LIST [STRING]
		do
			clear_state
			l_lines := split_lines (a_content)
			l_result_lines := apply_hunks (l_lines, a_diff.hunks)
			Result := join_lines (l_result_lines)
		ensure
			result_not_void: Result /= Void
		end

	apply_from_string (a_unified_diff: STRING; a_file_path: STRING)
			-- Parse and apply unified diff string.
			-- Sets `has_error` if parsing fails or application fails.
		require
			diff_not_void: a_unified_diff /= Void
			path_not_void: a_file_path /= Void
		local
			l_diff: detachable DIFF_RESULT
		do
			clear_state
			l_diff := parse_unified_diff (a_unified_diff)
			if attached l_diff as ld then
				apply (ld, a_file_path)
			else
				last_error := "Failed to parse unified diff"
			end
		ensure
			error_on_parse_fail: last_error /= Void implies has_error
		end

	write_reject_file (a_base_path: STRING)
			-- Write rejected hunks to .rej file.
			-- Creates file at `a_base_path` + ".rej"
		require
			path_not_void: a_base_path /= Void
			has_rejects: has_rejects
		local
			l_file: PLAIN_TEXT_FILE
			l_rej_path: STRING
			i: INTEGER
		do
			l_rej_path := a_base_path + ".rej"
			create l_file.make_create_read_write (l_rej_path)
			from i := 1 until i > rejected_hunks.count loop
				l_file.put_string (rejected_hunks [i].to_string)
				i := i + 1
			end
			l_file.close
		ensure
			rejects_unchanged: rejected_hunks.count = old rejected_hunks.count
		end

feature {NONE} -- Implementation

	clear_state
			-- Clear error and reject state.
		do
			last_error := Void
			rejected_hunks.wipe_out
		ensure
			no_error: last_error = Void
			no_rejects: rejected_hunks.is_empty
		end

	apply_hunks (a_lines: ARRAYED_LIST [STRING]; a_hunks: ARRAYED_LIST [DIFF_HUNK]): ARRAYED_LIST [STRING]
			-- Apply hunks to lines, return result.
		local
			l_result: ARRAYED_LIST [STRING]
			l_offset: INTEGER
			l_hunk: DIFF_HUNK
			l_hunk_result: TUPLE [lines: ARRAYED_LIST [STRING]; offset_delta: INTEGER; success: BOOLEAN]
			i: INTEGER
		do
			create l_result.make (a_lines.count)
			l_result.append (a_lines)
			l_offset := 0

			from i := 1 until i > a_hunks.count loop
				l_hunk := a_hunks [i]
				l_hunk_result := apply_single_hunk (l_result, l_hunk, l_offset)
				if l_hunk_result.success then
					l_result := l_hunk_result.lines
					l_offset := l_offset + l_hunk_result.offset_delta
				else
					rejected_hunks.extend (l_hunk)
				end
				i := i + 1
			end

			Result := l_result
		ensure
			result_not_void: Result /= Void
		end

	apply_single_hunk (a_lines: ARRAYED_LIST [STRING]; a_hunk: DIFF_HUNK; a_offset: INTEGER): TUPLE [lines: ARRAYED_LIST [STRING]; offset_delta: INTEGER; success: BOOLEAN]
			-- Apply single hunk at offset, return result and new offset delta.
		local
			l_result: ARRAYED_LIST [STRING]
			l_start: INTEGER
			l_pos: INTEGER
			l_delta: INTEGER
			l_success: BOOLEAN
			l_line: DIFF_LINE
			i: INTEGER
		do
			create l_result.make (a_lines.count + a_hunk.target_count)
			l_result.append (a_lines)

			if reverse then
				l_start := a_hunk.target_start + a_offset
			else
				l_start := a_hunk.source_start + a_offset
			end

			l_pos := l_start
			l_success := True
			l_delta := 0

			-- Verify context matches
			if not verify_hunk_context (a_lines, a_hunk, l_start) then
				l_success := False
			else
				-- Apply the hunk
				from i := 1 until i > a_hunk.lines.count loop
					l_line := a_hunk.lines [i]
					if reverse then
						-- Reverse mode: swap add/remove
						if l_line.is_added then
							-- In reverse, added lines are removed
							if l_pos >= 1 and l_pos <= l_result.count then
								l_result.go_i_th (l_pos)
								l_result.remove
								l_delta := l_delta - 1
							end
						elseif l_line.is_removed then
							-- In reverse, removed lines are added
							if l_pos >= 1 and l_pos <= l_result.count + 1 then
								l_result.go_i_th (l_pos)
								l_result.put_left (l_line.content)
								l_pos := l_pos + 1
								l_delta := l_delta + 1
							end
						else
							-- Context line
							l_pos := l_pos + 1
						end
					else
						-- Normal mode
						if l_line.is_removed then
							if l_pos >= 1 and l_pos <= l_result.count then
								l_result.go_i_th (l_pos)
								l_result.remove
								l_delta := l_delta - 1
							end
						elseif l_line.is_added then
							if l_pos >= 1 and l_pos <= l_result.count + 1 then
								l_result.go_i_th (l_pos)
								l_result.put_left (l_line.content)
								l_pos := l_pos + 1
								l_delta := l_delta + 1
							end
						else
							-- Context line
							l_pos := l_pos + 1
						end
					end
					i := i + 1
				end
			end

			Result := [l_result, l_delta, l_success]
		ensure
			result_not_void: Result /= Void
		end

	verify_hunk_context (a_lines: ARRAYED_LIST [STRING]; a_hunk: DIFF_HUNK; a_start: INTEGER): BOOLEAN
			-- Verify that context lines match.
		local
			l_pos: INTEGER
			l_expected: STRING
			l_line: DIFF_LINE
			i: INTEGER
		do
			Result := True
			l_pos := a_start

			from i := 1 until i > a_hunk.lines.count loop
				l_line := a_hunk.lines [i]
				if l_line.is_context or (not reverse and l_line.is_removed) or (reverse and l_line.is_added) then
					if l_pos >= 1 and l_pos <= a_lines.count then
						l_expected := l_line.content
						if not a_lines [l_pos].same_string (l_expected) then
							Result := False
						end
					else
						Result := False
					end
					l_pos := l_pos + 1
				end
				i := i + 1
			end
		end

	parse_unified_diff (a_diff: STRING): detachable DIFF_RESULT
			-- Parse unified diff format into DIFF_RESULT.
		local
			l_lines: LIST [STRING]
			l_result: DIFF_RESULT
			l_hunk: detachable DIFF_HUNK
			l_line: STRING
			l_source_start, l_target_start: INTEGER
			i: INTEGER
		do
			create l_result.make
			l_lines := a_diff.split ('%N')

			from i := 1 until i > l_lines.count loop
				l_line := l_lines [i]
				if l_line.count > 0 then
					if l_line.starts_with ("--- ") then
						l_result.set_source_path (l_line.substring (5, l_line.count))
					elseif l_line.starts_with ("+++ ") then
						l_result.set_target_path (l_line.substring (5, l_line.count))
					elseif l_line.starts_with ("@@ ") then
						-- Parse hunk header
						if attached l_hunk as lh then
							l_result.add_hunk (lh)
						end
						l_source_start := parse_hunk_start (l_line, False)
						l_target_start := parse_hunk_start (l_line, True)
						create l_hunk.make (l_source_start.max (1), l_target_start.max (1))
					elseif attached l_hunk as lh then
						if l_line.item (1) = '+' then
							lh.add_added_line (l_line.substring (2, l_line.count), lh.target_start + lh.target_count)
						elseif l_line.item (1) = '-' then
							lh.add_removed_line (l_line.substring (2, l_line.count), lh.source_start + lh.source_count)
						elseif l_line.item (1) = ' ' then
							lh.add_context_line (l_line.substring (2, l_line.count), lh.source_start + lh.source_count, lh.target_start + lh.target_count)
						end
					end
				end
				i := i + 1
			end

			if attached l_hunk as lh then
				l_result.add_hunk (lh)
			end

			Result := l_result
		end

	parse_hunk_start (a_header: STRING; a_target: BOOLEAN): INTEGER
			-- Parse start line from hunk header.
		local
			l_start, l_end: INTEGER
			l_marker: CHARACTER
		do
			Result := 1
			if a_target then
				l_marker := '+'
			else
				l_marker := '-'
			end
			l_start := a_header.index_of (l_marker, 1)
			if l_start > 0 then
				l_end := a_header.index_of (',', l_start)
				if l_end = 0 then
					l_end := a_header.index_of (' ', l_start + 1)
				end
				if l_end > l_start + 1 then
					Result := a_header.substring (l_start + 1, l_end - 1).to_integer
				end
			end
		end

	split_lines (a_text: STRING): ARRAYED_LIST [STRING]
			-- Split text into lines.
		local
			l_lines: LIST [STRING]
			l_line: STRING
			i: INTEGER
		do
			l_lines := a_text.split ('%N')
			create Result.make (l_lines.count)
			from i := 1 until i > l_lines.count loop
				l_line := l_lines [i]
				if l_line.count > 0 and then l_line.item (l_line.count) = '%R' then
					Result.extend (l_line.substring (1, l_line.count - 1))
				else
					Result.extend (l_line)
				end
				i := i + 1
			end
		end

	join_lines (a_lines: ARRAYED_LIST [STRING]): STRING
			-- Join lines with newlines.
		local
			i: INTEGER
		do
			create Result.make (a_lines.count * 80)
			from i := 1 until i > a_lines.count loop
				Result.append (a_lines [i])
				Result.append_character ('%N')
				i := i + 1
			end
		end

	write_file (a_path: STRING; a_lines: ARRAYED_LIST [STRING])
			-- Write lines to file.
		local
			l_file: PLAIN_TEXT_FILE
			i: INTEGER
		do
			create l_file.make_create_read_write (a_path)
			from i := 1 until i > a_lines.count loop
				l_file.put_string (a_lines [i])
				l_file.put_new_line
				i := i + 1
			end
			l_file.close
		end

invariant
	rejected_hunks_not_void: rejected_hunks /= Void

end
